---
---

<div id="cloud-bg" class="fixed inset-0 z-0 select-none">
  <canvas id="cloud-canvas" class="w-full h-full pointer-events-none"></canvas>
  <!-- Global floating cloud-computing icons layer -->
  <div id="bg-icons" class="absolute inset-0 pointer-events-none"></div>
</div>

<script>
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const canvas = document.getElementById('cloud-canvas');
  const ctx = canvas.getContext('2d');
  const reduceMul = prefersReduced ? 0.35 : 1;
  // Scroll reactivity state (parallax only)
  let scrollProgress = 0; // 0..1
  // Global web wobble phase
  let webT = 0;

  let DPR = Math.min(2, window.devicePixelRatio || 1);
  let W = 0, H = 0;
  function resize() {
    const rect = canvas.getBoundingClientRect();
  // Snap to integers to avoid subpixel gaps along edges
  W = Math.ceil(rect.width);
  H = Math.ceil(rect.height);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  // Node/edge graph representing microservices
  const TYPES = [
    { key: 'compute', color: '#60a5fa' },
    { key: 'db', color: '#34d399' },
    { key: 'storage', color: '#f59e0b' },
    { key: 'gateway', color: '#a78bfa' },
  ];

  const rand = (min, max) => Math.random() * (max - min) + min;

  // Fewer nodes by default to avoid overwhelming density
  const nodeCount = Math.floor(12 + Math.random() * 10);
  const nodes = [];
  for (let i = 0; i < nodeCount; i++) {
    const t = TYPES[Math.floor(Math.random() * TYPES.length)];
    const x0 = rand(60, window.innerWidth - 60);
    const y0 = rand(60, window.innerHeight - 60);
    nodes.push({
      x: x0,
      y: y0,
      vx: rand(-0.05, 0.05),
      vy: rand(-0.05, 0.05),
      r: rand(3, 6),
      type: t,
      pulse: Math.random() * Math.PI * 2,
      // anchor for springy "web" motion
      ax: x0,
      ay: y0,
    });
  }

  // Precompute edges to k nearest neighbors
  const K = 2; // lighter web connection count per node
  /** @type {{a:number,b:number,len:number,packets:Array<{p:number,speed:number,dir:number}>,seed:number}[]} */
  const edges = [];
  function rebuildEdges() {
    edges.length = 0;
    for (let i = 0; i < nodes.length; i++) {
      const dists = nodes.map((n, j) => ({ j, d: i === j ? Infinity : ((n.x - nodes[i].x)**2 + (n.y - nodes[i].y)**2) }));
      dists.sort((a,b) => a.d - b.d);
      for (let k = 0; k < K; k++) {
        const j = dists[k].j;
        if (j == null) continue;
        const key = i < j ? `${i}-${j}` : `${j}-${i}`;
        if (edges.some(e => (e.key === key))) continue;
        const len = Math.sqrt(dists[k].d);
        edges.push({ key, a: i, b: j, len, packets: [], seed: Math.random() * Math.PI * 2 });
      }
    }
    // seed few packets on edges (calmer)
    edges.forEach(e => {
      const count = Math.random() > 0.65 ? 1 : 0;
      for (let m = 0; m < count; m++) {
        e.packets.push({ p: Math.random(), speed: rand(0.002, 0.007), dir: Math.random() > 0.5 ? 1 : -1 });
      }
    });
  }
  rebuildEdges();

  // Mouse parallax and gentle attraction
  let mx = 0, my = 0, hasMouse = false;
  window.addEventListener('mousemove', (e) => { mx = e.clientX; my = e.clientY; hasMouse = true; });

  // Scroll-driven parallax only (no boosts or bursts)
  let scrollFactor = 1; // fixed to avoid speed changes with scroll
  function recomputeScrollFactor() {
    const maxH = Math.max(1, document.documentElement.scrollHeight - window.innerHeight);
    scrollProgress = Math.max(0, Math.min(1, window.scrollY / maxH)); // 0..1
  }
  window.addEventListener('scroll', recomputeScrollFactor, { passive: true });
  recomputeScrollFactor();

  // Click bursts (disabled by request; keep array for internal events if used)
  /** @type {Array<{x:number,y:number,life:number,edge:number}>} */
  const bursts = [];
  // window.addEventListener('click', (e) => {
  //   // disabled: avoid adding webs/packets on click
  // });

  // Controls (no on-screen UI; only programmatic via custom events)
  let paused = false;
  let speedMul = 1;
  let densityMul = 1;

  // Floating icon layer (AWS-biased)
  const iconLayer = document.getElementById('bg-icons');
  /** @type {Array<{el:HTMLElement,x:number,y:number,vx:number,vy:number,rot:number,vrot:number,size:number,depth:number}>} */
  const iconItems = [];
  const rng = (a,b) => Math.random() * (b - a) + a;
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const COLOR_POOL = ['#60a5fa','#34d399','#f59e0b','#a78bfa','#f472b6','#22d3ee'];

  // Generic and AWS-like glyphs (currentColor-stroked, brand-neutral)
  const ICONS_AWSY = [
    // Lambda (bolt)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M13 3L4 14h7l-1 7 9-11h-7z'/></svg>",
    // S3 bucket
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M5 7h14l-1 11a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3L5 7z'/><path d='M7 7a5 3 0 0 0 10 0'/></svg>",
    // RDS (database)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><ellipse cx='12' cy='6' rx='6' ry='3'/><path d='M6 6v6c0 1.7 2.7 3 6 3s6-1.3 6-3V6'/><path d='M6 12v6c0 1.7 2.7 3 6 3s6-1.3 6-3v-6'/></svg>",
    // Dynamo-like (hex stack)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 3l6 3.5v7L12 17l-6-3.5v-7L12 3z'/><path d='M6 10.5l6 3.5l6-3.5'/></svg>",
    // API Gateway (columns)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M7 8h4M7 12h6M7 16h4'/><path d='M18 8v8'/><path d='M16 10h4M16 14h4'/></svg>",
    // CloudFront (globe)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='9'/><path d='M3 12h18'/><path d='M12 3a14 14 0 0 1 0 18a14 14 0 0 1 0-18'/></svg>",
    // CloudWatch (eye)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z'/><circle cx='12' cy='12' r='3'/></svg>",
    // VPC-ish (shield)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 3l7 4v5c0 5-3.5 8-7 9-3.5-1-7-4-7-9V7l7-4z'/></svg>",
    // EKS/ECS (container grid)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='3' y='7' width='18' height='10' rx='2'/><path d='M7 7v10M11 7v10M15 7v10'/></svg>",
  ];
  const ICONS_GENERIC = [
    // Compute (CPU)
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='7' y='7' width='10' height='10' rx='2'/><path d='M9 3v3M15 3v3M9 21v-3M15 21v-3M3 9h3M3 15h3M21 9h-3M21 15h-3'/></svg>",
    // Network
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='6' cy='6' r='3'/><circle cx='18' cy='6' r='3'/><circle cx='12' cy='18' r='3'/><path d='M8.7 7.7L10.5 10m2.9 0 1.8-2.3M12 14.1V12'/></svg>",
    // Load balancer
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='6' r='2.5'/><path d='M12 8.5v5'/><path d='M6 18l6-4 6 4'/></svg>",
    // Queue / stream
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='4' y='5' width='6' height='14' rx='1'/><rect x='10' y='8' width='6' height='11' rx='1'/><path d='M20 12v6'/></svg>",
    // Lock
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='5' y='11' width='14' height='9' rx='2'/><path d='M8 11V8a4 4 0 0 1 8 0v3'/></svg>",
    // Key
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='7' cy='12' r='3'/><path d='M10 12h11'/><path d='M18 10v4'/></svg>",
    // Cog
    "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8z'/><path d='M3 12h2M19 12h2M12 3v2M12 19v2M5.6 5.6l1.4 1.4M17 17l1.4 1.4M18.4 5.6L17 7M7 17l-1.4 1.4'/></svg>",
  ];

  function targetIconCount() {
    const base = prefersReduced ? 14 : 26;
    return Math.max(10, Math.min(60, Math.floor(base * densityMul)));
  }

  function spawnIcon() {
    if (!iconLayer) return null;
    // 70% AWS-ish, 30% generic
    const svg = Math.random() < 0.7 ? pick(ICONS_AWSY) : pick(ICONS_GENERIC);
    const el = document.createElement('div');
    el.className = 'bg-icon';
    el.innerHTML = svg;
    const size = rng(36, 64);
    const svgEl = el.querySelector('svg');
    if (svgEl) { svgEl.style.width = `${size}px`; svgEl.style.height = `${size}px`; }
  // give each icon its own accent color and depth layer
  el.style.color = pick(COLOR_POOL);
    iconLayer.appendChild(el);
    // initial position and motion
    const x = rng(0, W - size);
    const y = rng(0, H - size);
  // slightly higher initial velocities so movement is noticeable
  const vx = rng(-0.06, 0.06);
  const vy = rng(-0.06, 0.06);
    const rot = rng(0, Math.PI * 2);
    const vrot = rng(-0.001, 0.001);
  const depth = Math.random(); // 0 (near) .. 1 (far)
    el.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${rot}rad)`;
  const item = { el, x, y, vx, vy, rot, vrot, size, depth };
    iconItems.push(item);
    return item;
  }

  function rebuildIcons() {
    if (!iconLayer) return;
    const want = targetIconCount();
    // remove extras
    while (iconItems.length > want) {
      const it = iconItems.pop();
      it?.el?.remove();
    }
    // add missing
    while (iconItems.length < want) spawnIcon();
  }

  // No DOM controls; values can be adjusted with custom events below.

  // Respond to toolbar events
  window.addEventListener('cloud-stress', () => {
    paused = false;
    speedMul = 1.6; densityMul = 1.6;
    // Add random bursts
    for (let i = 0; i < 3; i++) {
      bursts.push({ x: Math.random()*W, y: Math.random()*H, life: 1200, edge: Math.floor(Math.random()*edges.length) });
    }
  });
  window.addEventListener('cloud-reset', () => {
    paused = false; speedMul = 1; densityMul = 1;
    rebuildEdges();
  rebuildIcons();
  });
  window.addEventListener('cloud-burst', () => {
    bursts.push({ x: Math.random()*W, y: Math.random()*H, life: 1000, edge: Math.floor(Math.random()*edges.length) });
  });
  window.addEventListener('cloud-pause-toggle', () => {
  paused = !paused;
  });
  window.addEventListener('cloud-shuffle', () => {
    nodes.forEach(n => { n.x = Math.random()*W; n.y = Math.random()*H; });
    rebuildEdges();
  // randomize icon positions slightly
  iconItems.forEach(it => { it.x = rng(0, Math.max(0, W - it.size)); it.y = rng(0, Math.max(0, H - it.size)); });
  });

  function step(dt) {
  const sp = speedMul; // no scroll-based speed boost
    // Move nodes (with springy web + gentle wind)
    for (const n of nodes) {
      if (!paused) {
        // spring back to anchor (web tension)
        const k = 0.0025; // spring constant
        const fx = (n.ax - n.x) * k;
        const fy = (n.ay - n.y) * k;
        // gentle wind oscillation modulated by scroll
    const windAmp = (prefersReduced ? 0.35 : 0.9) * (0.6); // constant, not growing with scroll
        const wx = Math.sin(n.pulse * 0.8 + n.x * 0.01) * windAmp * 0.02;
        const wy = Math.cos(n.pulse * 0.8 + n.y * 0.01) * windAmp * 0.015;
        n.vx += (fx + wx) * dt;
        n.vy += (fy + wy) * dt;
    n.x += n.vx * dt * sp * reduceMul;
    n.y += n.vy * dt * sp * reduceMul;
      }
      // soft bounds
      if (n.x < 20 || n.x > W - 20) n.vx *= -1;
      if (n.y < 20 || n.y > H - 20) n.vy *= -1;

      // subtle mouse influence
      if (hasMouse) {
        const dx = mx - n.x;
        const dy = my - n.y;
        const d = Math.hypot(dx, dy) + 0.0001;
        const force = Math.min(0.015, 20 / (d * d)) * reduceMul;
        n.vx += (dx / d) * force * 0.1;
        n.vy += (dy / d) * force * 0.1;
      }

      // slow damping
      n.vx *= 0.988; n.vy *= 0.988;
  n.pulse += dt * 0.002 * sp;
    }

    // Packets along edges
    for (const e of edges) {
      for (const pkt of e.packets) {
        pkt.p += pkt.speed * dt * pkt.dir * sp;
        if (pkt.p < 0 || pkt.p > 1) {
          // reset to the other end with a new speed to make it feel alive
          pkt.dir *= -1;
          pkt.p = Math.max(0, Math.min(1, pkt.p));
          pkt.speed = rand(0.003, 0.012) * (0.7 + densityMul * 0.3);
        }
      }
    }

    // Consume bursts: add transient packets heading from click towards nearest edges
    for (let i = bursts.length - 1; i >= 0; i--) {
      const b = bursts[i];
  b.life -= dt * sp;
      if (b.life <= 0) { bursts.splice(i, 1); continue; }
      // find k nearest nodes to the burst center
      const targets = nodes
        .map((n, j) => ({ j, d: (n.x - b.x)**2 + (n.y - b.y)**2 }))
        .sort((a,b)=>a.d-b.d)
        .slice(0, 3)
        .map(t => t.j);
      for (const t of targets) {
        const partner = Math.floor(Math.random() * nodes.length);
        if (t === partner) continue;
        // add a temporary packet on the corresponding or new edge
        const key = t < partner ? `${t}-${partner}` : `${partner}-${t}`;
        let edge = edges.find(e => e.key === key);
        if (!edge) {
          edges.push({ key, a: t, b: partner, len: Math.hypot(nodes[t].x-nodes[partner].x, nodes[t].y-nodes[partner].y), packets: [], seed: Math.random() * Math.PI * 2 });
          edge = edges[edges.length - 1];
        }
        edge.packets.push({ p: Math.random(), speed: rand(0.01, 0.02) * densityMul, dir: Math.random() > 0.5 ? 1 : -1 });
      }
    }

    // Move icons
  const parallaxX = (hasMouse ? (mx / Math.max(1,W) - 0.5) : 0) * 0.006 * reduceMul;
  const parallaxY = (hasMouse ? (my / Math.max(1,H) - 0.5) : 0) * 0.006 * reduceMul;
    for (const it of iconItems) {
      if (!paused) {
    it.vx += (Math.random() - 0.5) * 0.0014 * speedMul * reduceMul;
    it.vy += (Math.random() - 0.5) * 0.0014 * speedMul * reduceMul;
        // clamp
    const maxV = 0.18 * speedMul * reduceMul;
        it.vx = Math.max(-maxV, Math.min(maxV, it.vx));
        it.vy = Math.max(-maxV, Math.min(maxV, it.vy));
    // ensure a minimal baseline drift so they never look static
    const base = 0.005 * dt * reduceMul;
    const dirX = it.vx >= 0 ? 1 : -1;
    const dirY = it.vy >= 0 ? 1 : -1;
    const depthMul = 0.35 + it.depth * 0.85; // far icons move less with parallax
    it.x += ((it.vx * dt) + base * dirX + parallaxX * it.size * depthMul) * reduceMul;
    it.y += ((it.vy * dt) + base * dirY + parallaxY * it.size * depthMul) * reduceMul;
        it.rot += (it.vrot * dt) * reduceMul;
        // bounce
        const pad = 10;
        const maxX = Math.max(pad, W - it.size - pad);
        const maxY = Math.max(pad, H - it.size - pad);
        if (it.x < pad || it.x > maxX) it.vx *= -1, it.x = Math.max(pad, Math.min(maxX, it.x));
        if (it.y < pad || it.y > maxY) it.vy *= -1, it.y = Math.max(pad, Math.min(maxY, it.y));
        it.el.style.transform = `translate3d(${it.x}px, ${it.y}px, 0) rotate(${it.rot}rad)`;
      }
    }
  }

  function draw() {
  ctx.clearRect(0, 0, W, H);
  // Uniform base fill to avoid any side vignettes or transparency bands
  ctx.fillStyle = '#111827'; // Tailwind gray-900
  ctx.fillRect(-1, -1, W + 2, H + 2);

  // Scroll parallax for the canvas content (subtle)
  const scrollAmp = prefersReduced ? 8 : 14; // subtle px range
  const shiftY = (scrollProgress - 0.5) * scrollAmp;
  ctx.save();
  ctx.translate(0, shiftY);

    // Edges
  ctx.lineWidth = 1.2;
    for (const e of edges) {
      const a = nodes[e.a];
      const b = nodes[e.b];
      const grad = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
  const alphaBase = 0.26;
    grad.addColorStop(0, `rgba(96,165,250,${alphaBase})`);
    grad.addColorStop(1, `rgba(167,139,250,${alphaBase})`);
      ctx.strokeStyle = grad;
      // spider-web style: slight curved sag between nodes
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const len = Math.hypot(dx, dy) + 0.0001;
      const nx = -dy / len;
      const ny = dx / len;
      const mx = (a.x + b.x) / 2;
      const my = (a.y + b.y) / 2;
      const sagBase = (prefersReduced ? 3 : 5); // constant sag
      // time-based wobble independent of scroll/mouse
      const wob = 0.5 + 0.5 * Math.sin(webT * 1.15 + e.seed);
      const sag = sagBase * wob;
      // slight along-tangent sway for more organic motion
      const tx = dx / len;
      const ty = dy / len;
      const sway = Math.cos(webT * 0.9 + e.seed * 1.7) * (prefersReduced ? 1 : 2);
      const cx = mx + nx * sag + tx * sway;
      const cy = my + ny * sag + ty * sway;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.quadraticCurveTo(cx, cy, b.x, b.y);
      ctx.stroke();

      // packets
      for (const pkt of e.packets) {
        const x = a.x + (b.x - a.x) * pkt.p;
        const y = a.y + (b.y - a.y) * pkt.p;
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
        ctx.beginPath();
  ctx.arc(x, y, 1.8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Nodes
    for (const n of nodes) {
      const glow = 0.35 + 0.25 * Math.sin(n.pulse);
      ctx.fillStyle = n.type.color;
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r + 0.5, 0, Math.PI * 2);
      ctx.fill();

      // outline with glow
      ctx.strokeStyle = `rgba(255,255,255,${0.15 + glow * 0.2})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r + 2.5, 0, Math.PI * 2);
      ctx.stroke();

      // tiny glyphs per type
      ctx.save();
      ctx.translate(n.x, n.y);
      ctx.scale(1, 1);
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = 'rgba(17,24,39,0.9)';
      ctx.lineWidth = 1;
      if (n.type.key === 'compute') {
        // CPU square
        const s = 6;
        ctx.strokeRect(-s/2, -s/2, s, s);
      } else if (n.type.key === 'db') {
        // DB cylinder
        ctx.beginPath();
        ctx.ellipse(0, -2, 3, 2, 0, 0, Math.PI * 2);
        ctx.moveTo(-3, -2);
        ctx.lineTo(-3, 3);
        ctx.moveTo(3, -2);
        ctx.lineTo(3, 3);
        ctx.stroke();
      } else if (n.type.key === 'storage') {
        // bucket
        ctx.beginPath();
        ctx.moveTo(-3, -3); ctx.lineTo(3, -3); ctx.lineTo(2, 3); ctx.lineTo(-2, 3); ctx.closePath();
        ctx.stroke();
      } else if (n.type.key === 'gateway') {
        // triangle
        ctx.beginPath();
        ctx.moveTo(0, -4); ctx.lineTo(4, 3); ctx.lineTo(-4, 3); ctx.closePath();
        ctx.stroke();
      }
      ctx.restore();
    }
  ctx.restore();
  }

  let last = performance.now();
  let raf;
  function loop(t) {
    const dt = Math.min(50, t - last);
    last = t;
  webT += dt * 0.0015; // advance wobble phase
  if (!paused) step(dt);
    draw();
    // Apply subtle parallax to icon layer container based on scroll (no velocity)
    if (iconLayer) {
      const scrollAmp = prefersReduced ? 6 : 10;
      const shiftY = (scrollProgress - 0.5) * scrollAmp;
      iconLayer.style.transform = `translate3d(0, ${shiftY.toFixed(2)}px, 0)`;
    }
    raf = requestAnimationFrame(loop);
  }
  raf = requestAnimationFrame(loop);

  // Initial icon population
  rebuildIcons();

  // Respawn some nodes occasionally so it "changes every time"
  setInterval(() => {
    if (prefersReduced) return;
    // Randomly jitter positions and rebuild edges
    nodes.forEach(n => { n.x += rand(-10, 10); n.y += rand(-10, 10); });
    // adjust population by densityMul
    const targetCount = Math.max(12, Math.min(60, Math.floor(nodeCount * densityMul)));
    if (nodes.length < targetCount && Math.random() > 0.4) {
      const t = TYPES[Math.floor(Math.random() * TYPES.length)];
      nodes.push({ x: rand(40, W-40), y: rand(40, H-40), vx: rand(-0.05,0.05), vy: rand(-0.05,0.05), r: rand(3,6), type: t, pulse: Math.random()*6.28 });
    } else if (nodes.length > targetCount && Math.random() > 0.7) {
      nodes.splice(Math.floor(Math.random() * nodes.length), 1);
    }
    rebuildEdges();
  // Occasionally add/remove icons subtly
  if (Math.random() > 0.6) rebuildIcons();
  }, 5000);

  // Clean up on navigation (Astro islands hydration safety)
  window.addEventListener('beforeunload', () => cancelAnimationFrame(raf));
</script>

<style>
  #cloud-bg { mix-blend-mode: normal; opacity: 1; }
  #cloud-canvas { position: absolute; inset: 0; display: block; filter: blur(3px) brightness(1.06) contrast(1.08); }
  #bg-icons .bg-icon { position: absolute; color: var(--accent-color, #60a5fa); opacity: 0.55; /* drop-shadow removed to avoid blur/vignette */ will-change: transform; }
  #bg-icons .bg-icon svg { display: block; width: 40px; height: 40px; stroke: currentColor; }
  @media (prefers-reduced-motion: reduce) {
    #cloud-bg { opacity: 0.45; }
  }
</style>
